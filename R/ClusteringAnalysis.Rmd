---
title: "Clustering Analysis"
author: ""
date: "2019-Mar-22"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      include = TRUE, 
                      eval = TRUE, 
                      fig.width = 6, fig.height = 4,
                      results='hold',
                      warning = FALSE,
                      message=FALSE,
                      cache = TRUE,
                      digits = 3) 
```

```{r,echo=FALSE,results='hide', message=FALSE}
# Packages and Data Parser
#Note: Be sure plyr is loaded before dplyr
PackageList =c("plyr","dplyr","tidyverse","lubridate","censusapi","forcats","kmeans","mclust","reshape2","ggplot2")
NewPackages=PackageList[!(PackageList %in% 
                            installed.packages()[,"Package"])]
if(length(NewPackages)) install.packages(NewPackages,repos = "http://cran.us.r-project.org")
lapply(PackageList,require,character.only=TRUE)#array function

source("taxiData.R")

options(tibble.print_max = Inf, tibble.print_min = 20) 
set.seed(1) #Always set the seed for reproducibility
```

Load and preprocess the data
```{r}
# Load 10K taxi rides
data <- taxiData(500000, cleanData = FALSE)$rawData %>%
  select(  # Only select identifiers and variables we want to use in clustering
    trip_id,
    taxi_id,
    company,
    dropoff_community_area,
    extras,
    fare,
    payment_type,
    pickup_community_area,
    tips,
    tolls,
    trip_end_timestamp,
    trip_miles,
    trip_seconds,
    trip_start_timestamp,
    trip_total,
    dropoff_census_tract,
    pickup_census_tract
  ) %>%
  mutate(  # Fix any data types that tibble doesn't get right automatically
    trip_id = as.character(trip_id),
    taxi_id = as.factor(taxi_id),
    extras = as.numeric(extras),
    tolls = as.numeric(tolls),
    trip_end_timestamp = as.POSIXct(trip_end_timestamp, format="%Y-%m-%dT%H:%M:%OS"),
    trip_start_timestamp = as.POSIXct(trip_start_timestamp, format="%Y-%m-%dT%H:%M:%OS"),
    trip_total = as.numeric(trip_total),
    dropoff_census_tract = as.factor(dropoff_census_tract),
    pickup_census_tract = as.factor(pickup_census_tract),
    pickup_timeofday = as.POSIXlt(trip_end_timestamp, format="%Y-%m-%dT%H:%M:%OS")$hour+
      as.POSIXlt(trip_end_timestamp, format="%Y-%m-%dT%H:%M:%OS")$min/60,
    pickup_time_mday = as.POSIXlt(trip_end_timestamp, format="%Y-%m-%dT%H:%M:%OS")$mday,
    pickup_time_mon = as.POSIXlt(trip_end_timestamp, format="%Y-%m-%dT%H:%M:%OS")$mon,
    pickup_time_wday = as.POSIXlt(trip_end_timestamp, format="%Y-%m-%dT%H:%M:%OS")$wday,
    pickup_time_yday = as.POSIXlt(trip_end_timestamp, format="%Y-%m-%dT%H:%M:%OS")$yday,
  ) %>%
  drop_na() %>% # Drop any row with an N/A value
  filter(
    extras < 200,  # Remove crazy $1,200+ extra outlier
    trip_seconds > 0,
    trip_miles > 0
  )

data <- as.data.frame(data)

cat("Number of rows after cleaning: ", nrow(data))
```

Perform clustering with the k-means algorithm. See if there is a clearly best value for `k` based on the inter- and intra-cluster error.

```{r}
# Scale the numeric values
scaled <- as.data.frame(data %>% select_if(is.numeric))
scaled <- scale(scaled[,-4])  # exclude Tolls for the moment

kMax <- 10
kvec <- 2:kMax
sse <- c()    # within-group sum of squared errors
ratio <- c()  # between-group SS / total SS
for(k in kvec) {
  message("running cluster ", k)
  model <- kmeans(scaled, centers = k, nstart = 50)
  sse = c(sse, model$tot.withinss)
  ratio = c(ratio, model$betweenss/model$totss)
}

par(mfrow=c(1,2))
plot(kvec, sse, "b", main="Within-group SSE")
plot(kvec, ratio, "b", main="Between-group SS / Total SS")
```

Normally, we'd select the number of clusters with the BIC method when there is not an obvious value for `k`. However, BIC seems to just select the largest number of clusters regardless of the range of clusters I give it (up to 20, after which it becomes a little more difficult to interpret and you start getting very small clusters which look more anamolous than insightful). Instead, I decided to look at the distribution for each value of k individually.

Interestingly, `k=5` gave some result worth pointing out:

```{r}
m.best <- 5
model <- kmeans(scaled, centers = m.best, nstart = 50)

# From scaled centers to original centers
centers <- sweep(model$centers %*% diag(attr(scaled, 'scaled:scale')), 2,
                 -attr(scaled, 'scaled:center'))

# Print the number of households in each cluster
cluster <- lapply(1:m.best, function(i)as.character(data[model$cluster==i, 1]))

for (i in 1:m.best) {
  cat("Number of rides in cluster ", i, ": ", length(cluster[[i]]), "\n")
}
```

Clusters 4 and 5 both seem to product significantly higher fares, although cluster 5 has pretty much no tips...
```{r}
comp.df <- cbind(data, model$cluster)
clusterColIndex <- ncol(comp.df)
names(comp.df)[clusterColIndex] <- "cluster"
comp.df$cluster <- as.factor(comp.df$cluster)

ggplot(comp.df, aes(x = cluster, y = fare)) + 
  geom_boxplot()
ggplot(comp.df, aes(x = cluster, y = tips)) + 
  geom_boxplot()
```

Looking at the pickup/dropoff community area per cluster, we can see that areas 56 and 76 spike for clusters 4 and 5. These happen to be the areas associated with Midway Airport and O'Hare Airport, respectively. Thus, it looks like airport traffic is driving systematically higher trips.

```{r, fig.width=4}
par(mfrow=c(1,1))
for (i in 1:m.best) {
  clusterData <- comp.df %>%
    filter(cluster == i)
  
  pickup <- clusterData %>%
    mutate(pickup_community_area = as.numeric(pickup_community_area)) %>%
    arrange(pickup_community_area)
  dropoff <- clusterData %>%
    mutate(dropoff_community_area = as.numeric(dropoff_community_area)) %>%
    arrange(dropoff_community_area)

  hist(pickup$pickup_community_area, breaks = seq(from=1, to=80, by=1), main=paste0("Cluster ", i, " pickup areas"))
  hist(dropoff$dropoff_community_area, breaks = seq(from=1, to=80, by=1), main=paste0("Cluster ", i, " dropoff areas"))
}
```

This still does not explain the tips. Looking at the payment type distribution per cluster, however, we see that cluster 4 is all credit cards while cluster 5 is mostly cash. In this dataset, cash tips are not recorded. Thus, this dataset is actually likely under-reporting the revenue gained from airport routes.

```{r}
plot(comp.df[comp.df$cluster == 4,]$payment_type, main="Cluster 4")
plot(comp.df[comp.df$cluster == 5,]$payment_type, main="Cluster 5")
```